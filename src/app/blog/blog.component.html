<div class="fxRow">
  <div class="NavBox" > <a routerLinkActive="active" routerLink="/Home">Home</a></div>
  <div class="NavBox"> <a routerLinkActive="active" routerLink="/Project">Projects</a></div>
  <div class="NavBox"> <a routerLinkActive="active" routerLink="/Contact">Contact</a></div>
  <div class="NavBox"> <a routerLinkActive="active" routerLink="/Resume">Resume </a></div>
</div>
<h1>Blog</h1>
 <app-post [title] = "'Multifunctionality of EchoBot'" [date]="'8/2/20'" [intro]="'Echo League was an amateur DotA 2 league that had around 200 teams competing each season. As such there was a lot of downtime for players, and as players often do they wanted to play and watch as many games as possible. As admins of a free league the admin team was also looking for a way to pay for some of the server costs, and though we had banner ads on the website I felt it necessary to do a bit more. For these reasons EchoBot had to evolve a bit over the course of the three seasons.'" [para1]="'Originally EchoBot was simply designed to have a few custom commands and to detect user questions (as previously written about,) but there came a time when the general channel was being spammed with requests for pick up games known as \'in-houses\' in which 10 players would get together and play a game without using the in-game functionality to find random teammates. Players often regard this has a superior way to play as you can play with higher quality teammates more often and have a higher chance of getting someone on your team who is actively communicating and trying to play as a team. All atempts to limit the number of requests were ignored and the lowest form of punishment available to the admin team was to mute the players on all channels, which seemed too harsh a punishment for just trying to play a games that the server was designed for. I came up with a solution that everyone found to be reasonable. EchoBot was given a command that would only be able to be used once every fifteen minutes which would alert everyone in the general chat that an in-house was being formed and how many players they needed.'" [para2]="Games for the league were also streamed on Twitch.tv if a team could get someone to stream and shoutcast (or \'cast'\) them. Anyone was allowed to be a shoutcaster (or '\caster\') but we had certain casters who were there to represent the league and as there was no production team they often had to organize everything themselves. I floated the idea of allowing EchoBot to have a dedicated Discord channel in which to post twitch links when casters went live, and every few minutes after to remind people they were still streaming. This was enthusiastically accepted by both the admin team and the casting community as it was one less thing the casters had to do, and one less thing the admin team had to worry about. Every few minutes the bot would scan the Twitch.tv API to determine if one of our casters was streaming. If they were then it would check the game, DotA 2, and if the title included \'Echo League\' then it would post a link in the channel. If it had been more than 30 minutes since they had been online last there would be a special message indicating that the caster had just gone live.'" [para3]="'Paying for everything that makes a league run isn't exactly expensive, but it\'s also not cheap. The admin team decided to partner with two advertisers who would give us a promo code to give out to our players and we would get a portion of each sale made with the promo code. All of us were aware this would\'nt net us any profits but it was a way to offset the costs. Banner ads were placed on the website, but there wasn\'t much traction. After the initial testing of EchoBot I decided to have it run ads on the Discord server every 5 hours. This was specifically chosen so that it would rotate the times the ads would run as Echo League had players from all over the globe. The ad copy and promo code would be messaged to the general channel and advertisers were rotated each time. An issue came up when EchoBot began running ads every 4 hours, then 3, etc. until it was running an ad every hour and we shut it down temporarily. While debugging I heard from another developer than the function `setInterval()` in JS may not work as intended. This hadn't been a problem before as I had only used it to check on things like the Twitch.tv API, not to post things at an interval.  '">
</app-post><br>
<app-post [title]="'A Direct Comparison of Skill Values'" [intro] = "'How do you quantify skill? We can say for sure that a certain person is well beyond another, but comparing two people equal in skill is extemely difficult, and often subjective. Now add 8 more people into that equation and it\'s a recipe for disaster.'" [para1]= "'During my time at Echo League I developed and programmed the skill conversion system from Valve Corps\' DotA Match Making Rating (MMR) to our in-house Echo League (EL) point system. The reason that the skill rating needed to be converted was to have a easily available way to directly compare players that was completely consistent. MMR in Valve\'s game DotA functions much in the same way that chess ELO works in that it is based on your win-rate against other players and adjusted based on their MMR. There is theoretically no maximum though the highest a single player has been able to reach is about 10,000 MMR. However, the player with the highest MMR at any particular point in time isn\'t necessarily the \'best\' player in the game at the time; just the one that is willing to put in the most time to play enough games to get there. In a similar vein, the player with the lowest MMR isn\'t necessarily the worst player in the game at that particular moment, just the player willing to endure enough games to get their rating down that low. In order to account for fluctuations like this, the EL point system was developed.'" [para2] ="'EL points were based soley off of a player\'s MMR. However, the range of EL points was much lower than the range that MMR could be. This was to group players into certain brackets without having an arbitrary \'high\' and \'low\' brackets. Points went from 1 to 256 and followed a sigmoidal curve to match how \'real\' skill grows slowly at first, but then will increase in how fast it grows as a player gets better, followed by slow growth again at the peak. Each EL point was an indication that a player had reached a certain MMR that would indicate an increase in \'real\' skill. For example, any player below 1500 MMR would only have one point. In this case, it was determined that anyone below 1500 MMR was more than likely the same skill, just with different numbers of games. Toward the middle of the MMR curve skill increased expoentially. Around 4000 MMR a change in MMR of 15 points would gain or lose you a point, however at this level of MMR a player would already have around 120 points, making an increase or decrease of one point fairly negligible. Now that each player has their EL points we can directly compare their skill. A player with 100 MMR and a player with 200 MMR are both 1 point, as you\'d expect considering 100 and 200 MMR are nearly impossible to reach without intentionally losing games. A player with 6000 MMR and a a player with 7000 MMR are both 256 points as you\'d also expect due to the fact that players of that level are all high enough level that they will automatically be put into the highest bracket. As with anything there were edge cases. Edge cases dealing with a team\'s point total rarely came up, and when they did it was unfortunately to the detriment of the team, but fortunately had no effect on the system as was intended. The only teams who exceeded point totals for each bracket were those who had to compete against teams with higher point totals. Edge cases with individual players were far more frequent and may have had a slight negative effect (in that teams were less likely to sign up if they had a player who would push them into a certain skill bracket), but kept lower brackets from being dominated by teams who had one player significantly above the average skill level.'" [para3] = "'With an ever-changing system the range for EL points in each bracket was changed every season to account for lessons learned and fluctuations in the player base. Ultimately I consider the system to be a success as it gave the league exactly what it needed and was easy enough to comprehend. The players were assisted with a \'EL point calculator\' that they could use to determine which bracket their team would play in and there were very few complaints.'" [date]="'7/26/2020'">
</app-post><br>
<app-post [title]="'The Chess Engine'" [date] = "'7/19/2020'" [intro]= "'It seems the easiest way to prove you have learned how to code is to develop a chess engine. Although I have not personally looked at many other chess engines to see how they work I can imagine they mainly look at material on the board and somewhat at the board position. Going off of this assumption I decided to write my own chess engine.'" [para1]="'When building my chess engine I didn\'t want to have to rely on any library that I would then possibly have to convert to yet another library (repeat ad nauseam.) I built my own chess board purely in JavaScript in order to be able to convert it over to whatever platform I chose in the future. From there I decided to have the program keep track of the board with a string of characters, two for each space and one for which color was to move next, a total of 129 characters. With a function to convert this string to a \'board\' Object and then other functions to look for moves of the pieces and compile those into an array from which the script can choose to move, we now have a very basic chess engine. The next step was to \'score\' the board. The script then looks at which pieces are left and what square they are on. Using classic chess weights for the pieces was easy enough, but the board position scores needed to be coded manually and each one was a general estimate of how much a piece was worth in each spot. For example: putting your knight in the corner is only marginally better than sacrificing it entirely so a knight in a corner spot is worth 2 points while most other places it is worth 3 to 3.25 points.'" [para2]="'The strength of a chess engine is related to how far into the future it can see. At this point my chess engine only looks one full move into the future. That is to say it will look at how the player can react to its next move and act accordingly. The limiting factor in how far it can look is due to the speed at which I want it to move. It doesn\'t suit my purposes to have a very strong, but very, very slow chess program since at this point most of the debugging is going to be done by actually playing the game against the script. In fact just recently I discovered a strange case in which the script would not checkmate the player, which turned out to be due to the computer looking for the player reaction and, not being able to find it, disregarded the move entirely. The speed aspect is also important to how the decision tree operates when the script looks more than one move ahead. When looking two or more moves ahead the script will determine every possible instance that can occur from the first move in the current board\'s Moves Array. Once the score for that first move is determined (based on the maximum score the script can accomplish for itself and the minimum score the player can accomplish for the scirpt) all other moves are compared to that score without first finding every possible move. If the script determines that a certain course of action couldn\'t possibly result in a better score than that first move it will stop looking and move on. If it determines that the new score is indeed higher than the first move\'s score then that move replaces the first move as the comparison value. This speeds up the process pretty significantly especially when looking deeper in the tree. Unfortunately it is also the current snag that is holding up any forward progress on the chess engine as it is a rather intricate process that requires more attention than I can give it at the moment.'">
</app-post><br>

<app-post [title] = "'Detecting User Questions'" [date]="'7/12/2020'" [intro]="'Moderating usually involves answering a lot of quesitons from new users, and some questions are much more common than others. Part of the scope of EchoBot was to detect users asking common questions and to automatically answer them. Obviously a bot detecting questions can lead to a lot of false positives which is why there was a lot of work put into determining when a message is a question and when it is not.'" [para1]="'Often users who come to ask questions will use a similar choice of words when asking those questions \'what are the divisions?\' or \'where is the skill calculator?\' In theory it should be easy enough to just plug these words into a `message.indexOf(x)` function and trigger the bot when certain words are >=0. In practice these words are also used in explanations. \'The \*divisions\* are X, Y and Z and you can find out \*what\* division you are in at (link).\''" [para2]="'And so we\'ve established a simple use case in which there is a false positive trigger. Notice how even though the question word \'what\' was used in order to trigger the bot our false positive still includes that word. Simply including question words is not enough to exclude our example. One layer deeper than looking for the presence of words is looking at their order. To determine if something is a question rather than an explanation we can see if `message.indexOf(\'what\')` is less than (but not -1) `message.indexOf(\'division\')`'" [para3]="'There may still be a few false positive trigger phrases left after this step, however the majority of the false positives left were filtered out by an approach that needed a lot less thinking: ignoring messages over 60 characters. As many of the longer messages would trigger simply due to the fact there were long and began with something like \'what you need to do is...\''">
</app-post> <br>

